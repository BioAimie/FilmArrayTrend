train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 20) { break() }
# on the fly, determine the number of clusters for this data set
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
sites[1]
rolling.density
rm(a)
sites[1]
i
site.periods <- periods[periods > as.character(site.starts[site.starts$CustomerSiteId==sites[i],'YearWeek'])]
l <- length(site.periods)
if(l < (train.weeks+test.weeks)) { break() }
l < (train.weeks+test.weeks)
rolling.density <- c()
j <- 12
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
nrow(train.set) < 20
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 20) { print(paste(site.periods[j], 'Not enough data!', sep=': ')) break() }
# on the fly, determine the number of clusters for this data set
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
for(j in train.weeks:(l-1)) {
# create the training set
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 20) { stop(paste(site.periods[j], 'Not enough data!', sep=': ')) } # break() }
# on the fly, determine the number of clusters for this data set
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 20) { break() }
print(site.periods[j])
# on the fly, determine the number of clusters for this data set
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
sites[i]
a <- cp.features[cp.features$CustomerSiteId==sites[i], ]
a <- a[with(a, order(Date)), ]
View(a)
head(a)
head(cp.features)
head(calendar.df)
periods
head(cp.features)
ggplot(cp.features, aes(x=YearWeek, fill=as.factor(CustomerSiteId))) + geom_bar() + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[seq(1, length(periods), 12)])
set.seed(1234)
site.rolling.density <- c()
for(i in 1:2) { #length(sites)) {
site.periods <- periods[periods > as.character(site.starts[site.starts$CustomerSiteId==sites[i],'YearWeek'])]
l <- length(site.periods)
if(l < (train.weeks+test.weeks)) { break() }
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 10) { break() }
# on the fly, determine the number of clusters for this data set
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
site.rolling.density <- rbind(site.rolling.density, rolling.density)
}
site.rolling.density
rolling.density
sites
cp.features <- merge(cp.spread, calendar.df[,c('Date','YearWeek')], by='Date')
train.weeks <- 12
test.weeks <- 1
max.clusters <- 10
set.seed(1234)
site.rolling.density <- c()
for(i in 1:length(sites)) {
site.periods <- periods[periods > as.character(site.starts[site.starts$CustomerSiteId==sites[i],'YearWeek'])]
l <- length(site.periods)
if(l < (train.weeks+test.weeks)) { break() }
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 10) { break() }
# on the fly, determine the number of clusters for this data set
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
site.rolling.density <- rbind(site.rolling.density, rolling.density)
}
rolling.density
sites
i
sites[i]
max.clusters <- 10
set.seed(1234)
site.rolling.density <- c()
for(i in 1:length(sites)) {
site.periods <- periods[periods > as.character(site.starts[site.starts$CustomerSiteId==sites[i],'YearWeek'])]
l <- length(site.periods)
if(l < (train.weeks+test.weeks)) { break() }
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 10) { break() }
# on the fly, determine the number of clusters for this data set
print('entering section to determine k')
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
print('entering section to cluster using k-means')
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
print('entering section to predict cluster using kNN as a training method')
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
print('entering section to find the change in cluster density')
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
# bind the data together to get a temporal view of density changes by site
print('entering section to bind data')
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
site.rolling.density <- rbind(site.rolling.density, rolling.density)
}
set.seed(1234)
site.rolling.density <- c()
for(i in 1:length(sites)) {
print(i)
site.periods <- periods[periods > as.character(site.starts[site.starts$CustomerSiteId==sites[i],'YearWeek'])]
l <- length(site.periods)
if(l < (train.weeks+test.weeks)) { break() }
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
print(site.periods[j])
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 10) { break() }
# on the fly, determine the number of clusters for this data set
print('entering section to determine k')
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
print('entering section to cluster using k-means')
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
print('entering section to predict cluster using kNN as a training method')
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
print('entering section to find the change in cluster density')
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
# bind the data together to get a temporal view of density changes by site
print('entering section to bind data')
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
site.rolling.density <- rbind(site.rolling.density, rolling.density)
}
i
cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
j
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j], ]
head(train.set)
site.periods
j
j-12
train.weeks
max.clusters <- 10
set.seed(1234)
site.rolling.density <- c()
for(i in 1:length(sites)) {
print(i)
site.periods <- periods[periods > as.character(site.starts[site.starts$CustomerSiteId==sites[i],'YearWeek'])]
l <- length(site.periods)
if(l < (train.weeks+test.weeks)) { break() }
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
print(site.periods[j])
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j] & cp.features$YearWeek >= site.periods[j-train.weeks], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 10) { break() }
# on the fly, determine the number of clusters for this data set
print('entering section to determine k')
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
print('entering section to cluster using k-means')
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
print('entering section to predict cluster using kNN as a training method')
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1] & cp.features$YearWeek >= site.periods[j-train.weeks], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
print('entering section to find the change in cluster density')
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
# bind the data together to get a temporal view of density changes by site
print('entering section to bind data')
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
site.rolling.density <- rbind(site.rolling.density, rolling.density)
}
rolling.density
site.rolling.density
cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j] & cp.features$YearWeek >= site.periods[j-train.weeks], ]
site.periods[j-train.weeks]
cp.features$YearWeek > site.periods[j-train.weeks]
site.periods[j-train.weeks]
site.periods[(j-train.weeks)]
site.periods[(j-train.weeks+1)]
site.periods[j+1]
cp.features <- merge(cp.spread, calendar.df[,c('Date','YearWeek')], by='Date')
train.weeks <- 12
test.weeks <- 1
max.clusters <- 10
set.seed(1234)
site.rolling.density <- c()
for(i in 1:length(sites)) {
print(i)
site.periods <- periods[periods > as.character(site.starts[site.starts$CustomerSiteId==sites[i],'YearWeek'])]
l <- length(site.periods)
if(l < (train.weeks+test.weeks)) { break() }
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
print(site.periods[j])
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j] & cp.features$YearWeek >= site.periods[(j-train.weeks+1)], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 10) { break() }
# on the fly, determine the number of clusters for this data set
print('entering section to determine k')
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
# perform k-means on the training set to get a cluster
print('entering section to cluster using k-means')
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
print('entering section to predict cluster using kNN as a training method')
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1] & cp.features$YearWeek >= site.periods[(j-train.weeks+1)], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
print('entering section to find the change in cluster density')
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
# bind the data together to get a temporal view of density changes by site
print('entering section to bind data')
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
site.rolling.density <- rbind(site.rolling.density, rolling.density)
}
train.set
(nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k <- min(which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)) - 1
sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1])
which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0))
which(sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1]) < 0)
rm(k)
sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1])
k.curve <- sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1])
which(k.curve < 0)
if(which(k.curve < 0)==0) print('yes!!')
if(which(k.curve < 0)) print('yes!!')
if(length(which(k.curve < 0))==0) print('yes!!')
k.curve <- sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1])
min(which(k.curve < 0)) - 1
min(which(k.curve > 0)) - 1
k.curve
which(k.curve > 0)
min(which(k.curve > 0))
min(which(k.curve < 0))
set.seed(1234)
site.rolling.density <- c()
for(i in 1:length(sites)) {
print(i)
site.periods <- periods[periods > as.character(site.starts[site.starts$CustomerSiteId==sites[i],'YearWeek'])]
l <- length(site.periods)
if(l < (train.weeks+test.weeks)) { break() }
rolling.density <- c()
for(j in train.weeks:(l-1)) {
# create the training set
print(site.periods[j])
train.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j] & cp.features$YearWeek >= site.periods[(j-train.weeks+1)], ]
# if the data set is too small, then skip forward in time
if(nrow(train.set) < 10) { break() }
# on the fly, determine the number of clusters for this data set
print('entering section to determine k')
wss <- (nrow(train.set[, as.character(unique(cp.df$AssayName))])-1)*sum(apply(train.set[, as.character(unique(cp.df$AssayName))], 2, var))
for (k in 2:max.clusters) wss[k] <- sum(kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers=k)$withinss)
k.curve <- sapply(2:length(wss), function(x) (wss[x-1] - wss[x])/wss[x-1])
if(length(which(k.curve < 0))==0) {
k.centers <- max.clusters
} else {
k.centers <- min(which(k.curve < 0)) - 1
}
# perform k-means on the training set to get a cluster
print('entering section to cluster using k-means')
k.fit <- kmeans(train.set[, as.character(unique(cp.df$AssayName))], centers = k.centers, iter.max = 100)
train.set$Cluster <- as.factor(unname(k.fit$cluster))
# use kNN with these labels and then predict the clustering of the next week
print('entering section to predict cluster using kNN as a training method')
k.knn <- train(Cluster~., data = train.set[, c(as.character(unique(cp.df$AssayName)),'Cluster')], method='knn')
predicted.set <- cp.features[cp.features$CustomerSiteId==sites[i] & cp.features$YearWeek <= site.periods[j+1] & cp.features$YearWeek >= site.periods[(j-train.weeks+1)], as.character(unique(cp.df$AssayName))]
predicted.set$Cluster <- predict(k.knn, newdata = predicted.set)
# find the change in density
print('entering section to find the change in cluster density')
train.total <- nrow(train.set)
train.density <- with(data.frame(train.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
predict.total <- nrow(predicted.set)
shift.density <- with(data.frame(predicted.set, Count = 1), aggregate(Count~Cluster, FUN=sum))
train.density$Density <- train.density$Count/train.total
shift.density$Density <- shift.density$Count/predict.total
# bind the data together to get a temporal view of density changes by site
print('entering section to bind data')
temp <- data.frame(CustomerSiteId = sites[i], YearWeek = site.periods[j+1], DensityShift = sum(abs((train.density$Density - shift.density$Density))/train.density$Density))
rolling.density <- rbind(rolling.density, temp)
}
site.rolling.density <- rbind(site.rolling.density, rolling.density)
}
head(site.rolling.density)
unique(site.rolling.density$CustomerSiteId)
head(site.rolling.density)
ggplot(site.rolling.density, aes(x=YearWeek, y=DensityShift)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[seq(1, length(periods), 12)])
ggplot(site.rolling.density, aes(x=YearWeek, y=DensityShift)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
ggplot(cp.features, aes(x=YearWeek)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
ggplot(cp.features, aes(x=YearWeek)) + geom_bar() + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
train.set
train.set
min(train.set$YearWeek)
min(train.set$YearWeek)
52-45
5
7+5
periods
periods[order(periods)]
ggplot(cp.features, aes(x=YearWeek)) + geom_bar() + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[order(periods)][seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
ggplot(site.rolling.density, aes(x=YearWeek, y=DensityShift)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[order(periods)][seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
periods
ggplot(site.rolling.density, aes(x=YearWeek, y=DensityShift)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[order(periods)][seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
periods[order(periods)][seq(1, length(periods), 12)]
site.rolling.density
class(site.rolling.density$YearWeek)
ggplot(site.rolling.density[with(site.rolling.density, order(YearWeek)), ], aes(x=YearWeek, y=DensityShift)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[order(periods)][seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
levels(site.rolling.density$YearWeek)
factor(site.rolling.density$YearWeek, levels = site.rolling.density[with(site.rolling.density, order(as.character(YearWeek))),'YearWeek'])
ggplot(site.rolling.density, aes(x=as.character(YearWeek), y=DensityShift)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[order(periods)][seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
ggplot(cp.features, aes(x=YearWeek)) + geom_bar() + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[order(periods)][seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90))
head(cp.features)
with(data.frame(cp.features, Count = 1), aggregate(Count~YearWeek+CustomerSiteId, FUN=sum))
merge(site.rolling.density, with(data.frame(cp.features, Count = 1), aggregate(Count~YearWeek+CustomerSiteId, FUN=sum)), by=c('YearWeek','CustomerSiteId')
merge(site.rolling.density, with(data.frame(cp.features, Count = 1), aggregate(Count~YearWeek+CustomerSiteId, FUN=sum)), by=c('YearWeek','CustomerSiteId'))
a <- merge(site.rolling.density, with(data.frame(cp.features, Count = 1), aggregate(Count~YearWeek+CustomerSiteId, FUN=sum)), by=c('YearWeek','CustomerSiteId'))
head(a)
ggplot(a, aes(x=as.character(YearWeek), y=DensityShift)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[order(periods)][seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90)) + geom_line(aes(x=YearWeek, y=Count, group=CustomerSiteId), data=a)
ggplot(a, aes(x=as.character(YearWeek), y=10*DensityShift)) + geom_bar(stat='identity') + facet_wrap(~CustomerSiteId) + scale_x_discrete(breaks = periods[order(periods)][seq(1, length(periods), 12)]) + theme(axis.text.x=element_text(angle=90)) + geom_line(aes(x=YearWeek, y=Count, group=CustomerSiteId), data=a)
start.sites
site.starts
site.rolling.density[site.rolling.density$CustomerSiteId=='26', ]
